### 页面结构
#### 主页面(Layout)
1. 根路由匹配 Layout 结构
2. Layout: 左 aside、右(header、main(router-view))
3. 左导航、右用户信息和导航数据

#### 登录页(Login)
1. 表单验证成功 -> 携带身份信息发起请求 -> 成功响应 -> 将响应数据存于Vuex和LocalStorage
2. 本地中若有令牌信息，先用上
3. 注意点:
   * 登录成功后 -> repalce('home'); commmit("存令牌信息")
   * 因为home在未登录前看不了，因此会再跳到当前Login，重复跳转会报错，应将二者交换
   * 去\about，但未登录，切换至/login，登录后应该跳到原先的目的地，而非固定死的
     * 未登录切换到的/login和指定切换的会有所不同，前者会接受到参数后者则不会
     * 那么根据有参数则代表，切换的地址为原地址。无参即代表，切换到主页
   * 登录之后不能再去/login，则展示login前查看是否已登录，若是则不动
   

#### 主页面头部(AppHeader)
1. 面包屑
   1. 联动着AppAside的导航
2. 展示用户信息
   1. 头部创建好时，携带令牌去请求用户信息接口，将响应的信息渲染（头像、用户名）
   2. 退出 -> token的清除(前端和后端)


### 前端路由
#### 路由守卫
1. SPA应用中有些地方，你没登录就不让看！
2. 路由元信息(meta)加个标识，有这个东西就代表，需要登录之后才能访问这个路由
3. 展示路由内容之前，先看看该路由是否需要登录
   
   ```javascript
   router.beforeEach((to, from, next){
      if(to.meta.requireAuth){  // 祖先需要登录，自身坑定也要登录
        next({name:'login'})
        return
      }else{ next() }
   } )
   ```
4. 页面中很多地方都需要登录后才能访问，那么每个路由都加个标识？
   1. 判断访问路由是否需要登录之前，可以先看看其**祖先路由**，是否需要登录(matched.some(r => r.meta.requireAuth))
   2. 若其祖先都需要登录，访问路由也就无需判断了 
   3. /aa/bb/cc ->  "/" & "/aa" & "/aa/bb" & "/aa/bb/cc"

### 项目设计
#### 权限管理
1. 有人可以用这个系统，有人则不能。那么给每个人都指定是否能使用该系统或资源？
2. 这样很麻烦，不如给人分个类别，有的类可以有的类则不能(老师能，学生不能)

### 思维逻辑
#### 基本框架搭建出来，之后再考虑扩展
#### 一些操作都封装成API，有利于理解和维护
#### 添加东西，首先明确接口规定携带什么样格式的数据，才会正确添加（规范）
#### 接口函数获取信息，拿到信息后会执行什么操作，应写成函数
   1. getAllMenu 获取所有菜单信息
   2. loadMenus  "加载"菜单(存储信息、判断成与否)
#### 一个组件有两种状态，使用时应明确当前是那种状态
#### 数据和页面之间的绑定，UI?
#### 封装组件：先将之前的照搬下来实现，之后再进一步细化
   1. 明确组件核心的功能是什么！
#### 未使用过的东西，不会没事，学习别人是如何做的，不要将自己定死了

### 项目注意点
#### SCSS 变量的问题
1. 样式变量在自身中私有 
   * c1.scss -> c1.css 
   * c2.scss -> c2.css 
   * 组件样式并非 c1.scss + c2.scss -> c3.css , 而是 c1.css + c2.css -> c3.css 它们的变量不共享
2. 定义的全局样式变量，想在每个组件中应用
   * 每个地方都引用 @import '~@/styles/variables.scss'
   * 脚手架帮忙，自动帮我们把全局样式导入到每个.vue 中(插入到头部)
     * sass-loader = 8 : prepenData
     * sass-loader > 8 : additionalData

#### 路由器匹配顺序
1. routes 路由数组，路由器匹配是从索引 0 开始的、从上下至下、有顺序的匹配。
   * [ {CHD:[{},{}]} , {CHD:[{},{}]} ]
   * 0-0 -> 0-1 -> 1-0 -> 1-1
2. 遇到绝对路径不管父级是啥，只要匹配上就行
   {path:'/',children:[{path:'/login'}]}

#### 路由组件的书写顺序
1. 写结构
2. 注册路由
3. 写位置

#### 导入组件的顺序
1. 引入组件构造函数
2. 注册组件
3. 组件标签

#### 组件的命名
1. AppAside -> HTM5 aside
2. 最好以两个单词组成 -> LoginIndex 大驼峰

#### Vuex 的使用时机
1. 侧边栏的伸缩由 isCollapse 决定 -> AppAside 组件
2. 两个按钮想控制侧边栏的伸缩 -> AppHeader 组件
3. 可将 isCollapse 状态存于 Vuex，但是呢只有两个组件会用到，这其实不是 Vuex 的最佳场景

#### 组件间数据共享
1. 状态存于父，父将能修改其的方法传于子
   * 侧边组件的伸缩由其 isCollapse 决定。
   * 头组件中两按钮想控制其伸缩，因此它们应该能修改 isCollapse，但两者属于兄弟。
   * isCollapse 存于 Layout 中，将其传递给 AppAside，伸缩由传递的数据决定
   * Layout 中定义能修改 isCollapse 的方法，将其传递给 AppHeader，其中按钮点击触发方法，导致 isCollapse 改变，从而导致 AppAside 的渲染改变

#### 接口
1. 接口 interface
   1. method + url (服务接口)
   2. 函数 (应用程序接口，API)          
   3. UI (User Inteface)
   * 规范！ POST方法、正确的请求体(phone、psd)和正确的URL -> 才能获得服务(这个接口的规范) 你必须怎样怎样才能判断登录与否
   * 函数实现了某种功能，底层我们不关心，调用函数，函数代码执行，替我们完成了某些功能。函数已经规定的各个参数该传什么，规定也有接口这个意思
   * 左边5cm 右边10cm 的管子，对接不上，接口就是规范 -> 大小只有严丝合缝才能拧在一起
2. 与服务器沟通的桥梁，为我们提供数据
3. 接口会对传递的数据作指定"规范"的解析
   1. 接口要求 content-type 为 application/json  -> 传递的应为 JSON 数据
   2. 接口要求 content-type 为 application/x-www-form-urlencoded  -> 传递的应为 表单 数据
4. 项目中会频繁去请求接口以获得数据，那么肯定会如以下这样写
   * request({url:'',method:'POST',data:'urlencoded'})
   * 项目中会请求100个接口，就要写100个request。
   * 而且有的地方会重复的请求相同的接口(50个)，若请求的接口炸了，要换个地方咋办？
   * 因此，我们应该封装以下接口相关的请求函数，如上述的情况发生，我们只需改一下接口地址即可！
5. 频繁的请求服务接口，这是很不好滴
   1. 变量A，请求发送后值变为true,发送请求前看看A值只要是 true，那么请求不发送。Login中就会应用遮罩
   2. debounce(防抖)和throttle(节流)  -> CD 和 打断回城

#### Status
1. 200
   * mean: 客户端和服务器之间能连上、连接没问题、物理上连起来了、和接口连接成功、这次通话是正常的

#### Promise
1. Promise 要花一点时间处理一个事情，当他把事情处理完，之后我该干什么
2. Promise 服务于谁，当它服务的人结束之后，该干什么
3. 表单验证完之后，去登录验证，登录验证完之后，执行操作。 将这一套流程先大致用Promise标识一下（一个一个的环节？）
   1. vaildate().then(() => login(data)).then(() => console.log)
   2. 每个Promise都有自己服务的人，P1(表单验完之后)、P2(登录验证完之后)、P3路由跳转与提示
4. 时刻保证Promise状态的**正确表述**
   * 成功那么Promise成功，失败Promise失败(return Promise.reject() || throw new Error())
   * 后续可能根据刷新token的成功或失败作进一步处理

#### Axios
1. axios请求的基本过程
   1. 无请求拦截器: axios(options)  拿着基本请求报文 "直接" 发送XHR请求
   2. 有请求拦截器: axios(options)  拿着基本报文 "异步" 执行拦截器，后发请求
2. 拦截器
   1. 请求拦截器是在发起请求前对请求报文走一套逻辑
      * 请求拦截器逻辑中报错了，那么reject axios Promise 
   2. 响应拦截器是在响应到到达后，拿着响应结果走一套逻辑，然后用其解决请求Promise
      * 并非  服务器 --->拦截数据----> 客户端
      * 而是  服务器 ---------------> 客户端 --拦截数据---> Promise res
   3. 响应拦截器，响应状态为2xx走一套逻辑，不是2xx走另一套逻辑，不管走哪一套 **axios Promise 被 "解决"为 拦截器函数返回值**
      * 原先的响应结果是直接解决或拒绝的，而有了拦截器那么解决或拒绝是根据拦截器函数的返回值或异常的抛出

#### Token失效的处理
1. Token象征着用户本人，被人得到了会很危险。可以偷偷删掉你的论文。
2. 为了安全起见 Token 会有时效，若被人得到了过期的 Token，不用担心这没啥用。
3. 因此 Token 可能在用户访问网页期间突然噶了，这会导致用用着突然跳到登录页了，这个网页你用着如何？
4. Token若失效了，在代码层面尝试获取新的 Token，无需用户重新登录。为此有以下两种方法，实现代码层面获取新Token：
   1. 请求发起前，查看Token是否将要过期或已经过期了，等刷新完Token后再发起请求
   2. 请求失败了，若是Token失效的原因，则刷新完Token后重新发起请求（当前项目使用）
5. 暂不管什么时候去刷新token，而是先去封装好如何刷新token
   1. 携带refresh_token发起请求，成功则重新赋值新的tokenInfo，失败则跳转至登录页让用户重新登录
6. 多次刷新Token导致的问题
   1. 问题描述
      1. refresh_token是一次性的，刷新Token携带的是失效的refresh_token，那么刷新请求将失败从而跳转到登录页
      2. 瞬间发起两次携带着失效Token的请求(401)，从而会引起两次刷新Token的请求，就会携带一样的refresh_token去请求
      3. 第一个请求会正确响应，第二个会因为携带无效refresh_token，响应false，之后跳转至登录页
   2. 解决方案
      1. 刷新Token还在进行中，那么就不要再次发起重复的刷新请求了。
      2. 那哥们去买答案了，我等他买到了一起看 
7. TokenInfo: access_token(有它才能向接口请求数据)、expires_in(access_token过期时间段)、refresh_token(刷新TokenInfo)

#### Vue2.x响应式优化
1. 一些用不到的数据，不要也放在响应式数据上，Vue会为其添加GET/SET

#### v-model
1. <upload-image-unit v-model="course.courseListImg></upload-image-unit>
   * v-model就是让value属性双向绑定，因此upload-image-unit内部可通过prop接收
   * 组件内不应该直接修改value值，应该通过input事件让父组件自己修改（固定死的）。
   * 子组件想要修改value,就需出发input事件并将值以参数传递
   * this.$emit('input',url)
2. v-model:MarkDown -> value -> html
   * watch text-editor的问题